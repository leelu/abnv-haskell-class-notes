
==================== FINAL INTERFACE ====================
2016-03-15 13:59:36.180142 UTC

interface maze_GoKnX7KbWw6L6IQg5IY6eg:Lib 7103
  interface hash: cf0069e50990ce5f55c6b478aa45d166
  ABI hash: 7142880d25ce1be8bfcc25c17be280b2
  export-list hash: f8facaa4e6e3bdd9f50c226a411a3976
  orphan hash: 298fd387875194d9e1ba0e00076f9c95
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.someFunc
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set 7116dff3002cb8f8fc1c63ac63f4ea50
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base e94d20329e6707c26460899044ee8ac3
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
af4f6b0a3910f299578d32f952a46abe
  $fEqDir :: GHC.Classes.Eq Lib.Dir
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Dir Lib.$fEqDir_$c== Lib.$fEqDir_$c/= -}
af4f6b0a3910f299578d32f952a46abe
  $fEqDir_$c/= :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.False Lib.Down -> GHC.Types.True }
                   Lib.Down
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.True Lib.Down -> GHC.Types.False } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fEqDir_$c== :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lib.Dir ds1 :: Lib.Dir ->
                 case ds of wild {
                   Lib.Right
                   -> case ds1 of wild1 {
                        Lib.Right -> GHC.Types.True Lib.Down -> GHC.Types.False }
                   Lib.Down
                   -> case ds1 of wild1 {
                        Lib.Right -> GHC.Types.False Lib.Down -> GHC.Types.True } }) -}
6f3f06d130aa862b1403d0e24d09db22
  $fEqMaze :: GHC.Classes.Eq Lib.Maze
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Maze Lib.$fEqMaze_$c== Lib.$fEqMaze_$c/= -}
b61c3062a41d5cb7c5f52d88fb843a7b
  $fEqMaze1 :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Lib.$fEqMaze_$s$fEq(,)1 -}
6f3f06d130aa862b1403d0e24d09db22
  $fEqMaze_$c/= :: Lib.Maze -> Lib.Maze -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),U)><S(SLL),1*U(1*U(U),1*U(U),U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Maze b :: Lib.Maze ->
                 case Lib.$fEqMaze_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6f3f06d130aa862b1403d0e24d09db22
  $fEqMaze_$c== :: Lib.Maze -> Lib.Maze -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),U)><S(SLL),1*U(1*U(U),1*U(U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Lib.Maze w1 :: Lib.Maze ->
                 case w of ww { Lib.Maze ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { Lib.Maze ww7 ww8 ww9 ->
                 case ww7 of ww10 { GHC.Types.I# ww11 ->
                 Lib.$w$c== ww5 ww2 ww3 ww11 ww8 ww9 } } } }) -}
e2f74cb76d3fe2abccaea0aa7ea29106
  $fEqMaze_$s$fEq(,) ::
    GHC.Classes.Eq ((GHC.Types.Int, GHC.Types.Int), Lib.Dir)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Types.Int, GHC.Types.Int), Lib.Dir)
                  (GHC.Classes.$fEq(,)_$c==
                     @ (GHC.Types.Int, GHC.Types.Int)
                     @ Lib.Dir
                     Lib.$fEqMaze1
                     Lib.$fEqDir)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ (GHC.Types.Int, GHC.Types.Int)
                     @ Lib.Dir
                     Lib.$fEqMaze1
                     Lib.$fEqDir) -}
48d82fde32b08760d9643aa818ef1096
  $fEqMaze_$s$fEq(,)1 ::
    GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fEqWall :: GHC.Classes.Eq Lib.Wall
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ Lib.Wall Lib.$fEqWall_$c== Lib.$fEqWall_$c/= -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fEqWall_$c/= :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.False Lib.Closed -> GHC.Types.True }
                   Lib.Closed
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.True Lib.Closed -> GHC.Types.False } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fEqWall_$c== :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lib.Wall ds1 :: Lib.Wall ->
                 case ds of wild {
                   Lib.Open
                   -> case ds1 of wild1 {
                        Lib.Open -> GHC.Types.True Lib.Closed -> GHC.Types.False }
                   Lib.Closed
                   -> case ds1 of wild1 {
                        Lib.Open -> GHC.Types.False Lib.Closed -> GHC.Types.True } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir :: GHC.Classes.Ord Lib.Dir
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Dir
                  Lib.$fEqDir
                  Lib.$fOrdDir_$ccompare
                  Lib.$fOrdDir_$c<
                  Lib.$fOrdDir_$c<=
                  Lib.$fOrdDir_$c>
                  Lib.$fOrdDir_$c>=
                  Lib.$fOrdDir_$cmax
                  Lib.$fOrdDir_$cmin -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$c< :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.False Lib.Down -> GHC.Types.True }
                   Lib.Down -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$c<= :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Lib.Down
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.False Lib.Down -> GHC.Types.True } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$c> :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Lib.Down
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.True Lib.Down -> GHC.Types.False } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$c>= :: Lib.Dir -> Lib.Dir -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.True Lib.Down -> GHC.Types.False }
                   Lib.Down -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$ccompare :: Lib.Dir -> Lib.Dir -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Dir b :: Lib.Dir ->
                 case a of wild {
                   Lib.Right
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.EQ Lib.Down -> GHC.Types.LT }
                   Lib.Down
                   -> case b of wild1 {
                        Lib.Right -> GHC.Types.GT Lib.Down -> GHC.Types.EQ } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$cmax :: Lib.Dir -> Lib.Dir -> Lib.Dir
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: Lib.Dir y :: Lib.Dir ->
                 case x of wild {
                   Lib.Right -> y
                   Lib.Down -> case y of wild1 { DEFAULT -> Lib.Down } }) -}
af4f6b0a3910f299578d32f952a46abe
  $fOrdDir_$cmin :: Lib.Dir -> Lib.Dir -> Lib.Dir
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: Lib.Dir y :: Lib.Dir ->
                 case x of wild {
                   Lib.Right -> case y of wild1 { DEFAULT -> Lib.Right }
                   Lib.Down -> y }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall :: GHC.Classes.Ord Lib.Wall
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Wall
                  Lib.$fEqWall
                  Lib.$fOrdWall_$ccompare
                  Lib.$fOrdWall_$c<
                  Lib.$fOrdWall_$c<=
                  Lib.$fOrdWall_$c>
                  Lib.$fOrdWall_$c>=
                  Lib.$fOrdWall_$cmax
                  Lib.$fOrdWall_$cmin -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$c< :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.False Lib.Closed -> GHC.Types.True }
                   Lib.Closed -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$c<= :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Lib.Closed
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.False Lib.Closed -> GHC.Types.True } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$c> :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Lib.Closed
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.True Lib.Closed -> GHC.Types.False } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$c>= :: Lib.Wall -> Lib.Wall -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.True Lib.Closed -> GHC.Types.False }
                   Lib.Closed -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$ccompare :: Lib.Wall -> Lib.Wall -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lib.Wall b :: Lib.Wall ->
                 case a of wild {
                   Lib.Open
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.EQ Lib.Closed -> GHC.Types.LT }
                   Lib.Closed
                   -> case b of wild1 {
                        Lib.Open -> GHC.Types.GT Lib.Closed -> GHC.Types.EQ } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$cmax :: Lib.Wall -> Lib.Wall -> Lib.Wall
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: Lib.Wall y :: Lib.Wall ->
                 case x of wild {
                   Lib.Open -> y
                   Lib.Closed -> case y of wild1 { DEFAULT -> Lib.Closed } }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fOrdWall_$cmin :: Lib.Wall -> Lib.Wall -> Lib.Wall
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: Lib.Wall y :: Lib.Wall ->
                 case x of wild {
                   Lib.Open -> case y of wild1 { DEFAULT -> Lib.Open }
                   Lib.Closed -> y }) -}
af4f6b0a3910f299578d32f952a46abe
  $fShowDir :: GHC.Show.Show Lib.Dir
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Dir
                  Lib.$fShowDir_$cshowsPrec
                  Lib.$fShowDir_$cshow
                  Lib.$fShowDir_$cshowList -}
af4f6b0a3910f299578d32f952a46abe
  $fShowDir1 :: Lib.Dir -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lib.Dir eta :: GHC.Base.String ->
                 case ds of wild {
                   Lib.Right
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowDir3)
                        eta
                   Lib.Down
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowDir2)
                        eta }) -}
356bcddb5d9c800b5d42bebafe54fde7
  $fShowDir2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Down"#) -}
cce9f5d4f356043a603d3e6b1320d9ba
  $fShowDir3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Right"#) -}
af4f6b0a3910f299578d32f952a46abe
  $fShowDir_$cshow :: Lib.Dir -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.Dir ->
                 case x of wild {
                   Lib.Right -> Lib.$fShowDir3 Lib.Down -> Lib.$fShowDir2 }) -}
af4f6b0a3910f299578d32f952a46abe
  $fShowDir_$cshowList :: [Lib.Dir] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Dir Lib.$fShowDir1) -}
af4f6b0a3910f299578d32f952a46abe
  $fShowDir_$cshowsPrec :: GHC.Types.Int -> Lib.Dir -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int ds1 :: Lib.Dir eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Lib.Right
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowDir3)
                        eta
                   Lib.Down
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowDir2)
                        eta }) -}
6f3f06d130aa862b1403d0e24d09db22
  $fShowMaze :: GHC.Show.Show Lib.Maze
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Maze
                  Lib.$fShowMaze_$cshowsPrec
                  Lib.$fShowMaze_$cshow
                  Lib.$fShowMaze_$cshowList -}
6f3f06d130aa862b1403d0e24d09db22
  $fShowMaze1 :: Lib.Maze -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Lib.Maze ->
                 case w of ww { Lib.Maze ww1 ww2 ww3 ->
                 Lib.$w$cshowsPrec 0 ww1 ww2 ww3 }) -}
7819620875e08ce44a9784a6162a52fb
  $fShowMaze2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
06e21cc92ff74ed82449d827651f8428
  $fShowMaze3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "openMazeGates = "#) -}
d27576b74d9959e009aec88eade34b00
  $fShowMaze4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "mazeHeight = "#) -}
a53741e90e22a273d765382209b0f7ce
  $fShowMaze5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
280ff3defc89b8661439e781cbc0b7a0
  $fShowMaze6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "mazeWidth = "#) -}
77c09022cb8e996956e85b3bfec917cf
  $fShowMaze7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Maze {"#) -}
dcc05ad27101e4224a17f8b118d3e2b5
  $fShowMaze8 :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Lib.$fShowMaze_$s$fShow(,)1 -}
6f3f06d130aa862b1403d0e24d09db22
  $fShowMaze_$cshow :: Lib.Maze -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U),U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.Maze ->
                 Lib.$fShowMaze_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6f3f06d130aa862b1403d0e24d09db22
  $fShowMaze_$cshowList :: [Lib.Maze] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Maze Lib.$fShowMaze1) -}
6f3f06d130aa862b1403d0e24d09db22
  $fShowMaze_$cshowsPrec ::
    GHC.Types.Int -> Lib.Maze -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U(U),U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Lib.Maze ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Maze ww3 ww4 ww5 ->
                 Lib.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
29b2ab6504bdae4c062be55c8fae9d4d
  $fShowMaze_$s$fShow(,) ::
    GHC.Show.Show ((GHC.Types.Int, GHC.Types.Int), Lib.Dir)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Types.Int, GHC.Types.Int), Lib.Dir)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ (GHC.Types.Int, GHC.Types.Int)
                     @ Lib.Dir
                     Lib.$fShowMaze8
                     Lib.$fShowDir)
                  Lib.$fShowMaze_$s$fShow(,)_$cshow1
                  Lib.$fShowMaze_$s$fShow(,)_$cshowList -}
754a983ec1b123cb17387ff7375d898a
  $fShowMaze_$s$fShow(,)1 ::
    GHC.Show.Show (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowInt)
                  Lib.$fShowMaze_$s$fShow(,)_$cshow
                  Lib.$fShowMaze_$s$fShow(,)_$cshowList1 -}
2eae9baba17973880d84f418b28b41ac
  $fShowMaze_$s$fShow(,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U))>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: (GHC.Types.Int, GHC.Types.Int) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowInt
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
76f2f5d94d7f650807b9c0ce0e26dfc0
  $fShowMaze_$s$fShow(,)_$cshow1 ::
    ((GHC.Types.Int, GHC.Types.Int), Lib.Dir) -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U(U),U(U)),U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: ((GHC.Types.Int, GHC.Types.Int), Lib.Dir) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ Lib.Dir
                   Lib.$fShowMaze8
                   Lib.$fShowDir
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1a660348e418013be514ad3cfc10454d
  $fShowMaze_$s$fShow(,)_$cshowList ::
    [((GHC.Types.Int, GHC.Types.Int), Lib.Dir)] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: [((GHC.Types.Int, GHC.Types.Int), Lib.Dir)]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ ((GHC.Types.Int, GHC.Types.Int), Lib.Dir)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ (GHC.Types.Int, GHC.Types.Int)
                      @ Lib.Dir
                      Lib.$fShowMaze8
                      Lib.$fShowDir
                      GHC.Show.shows18)
                   eta
                   eta1) -}
bad2919de467809499dd3da40a1a60d0
  $fShowMaze_$s$fShow(,)_$cshowList1 ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: [(GHC.Types.Int, GHC.Types.Int)]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      GHC.Show.shows18)
                   eta
                   eta1) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fShowWall :: GHC.Show.Show Lib.Wall
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Wall
                  Lib.$fShowWall_$cshowsPrec
                  Lib.$fShowWall_$cshow
                  Lib.$fShowWall_$cshowList -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fShowWall1 :: Lib.Wall -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lib.Wall eta :: GHC.Base.String ->
                 case ds of wild {
                   Lib.Open
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowWall3)
                        eta
                   Lib.Closed
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowWall2)
                        eta }) -}
fa245a60bcdb851ae82a86d2a1aaedcf
  $fShowWall2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Closed"#) -}
1a93646d5571d58c7a2b7496c3e9adac
  $fShowWall3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Open"#) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fShowWall_$cshow :: Lib.Wall -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lib.Wall ->
                 case x of wild {
                   Lib.Open -> Lib.$fShowWall3 Lib.Closed -> Lib.$fShowWall2 }) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fShowWall_$cshowList :: [Lib.Wall] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Wall Lib.$fShowWall1) -}
c583bed3ebcdc6b95e568cf7d2cf1954
  $fShowWall_$cshowsPrec ::
    GHC.Types.Int -> Lib.Wall -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int ds1 :: Lib.Wall eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Lib.Open
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowWall3)
                        eta
                   Lib.Closed
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Lib.$fShowWall2)
                        eta }) -}
793a1f6a1b82f281cfab7e45bc500873
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> Data.Set.Base.Set Lib.OpenEdge
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Data.Set.Base.Set Lib.OpenEdge
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: Data.Set.Base.Set Lib.OpenEdge
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Types.Int
                   ww5 :: Data.Set.Base.Set Lib.OpenEdge ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww3) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> Data.Set.Base.$fEqSet_$c==
                             @ (Lib.Coord, Lib.Dir)
                             Lib.$fEqMaze_$s$fEq(,)
                             ww2
                             ww5 } } } }) -}
2eda97d9f53aa8fcce887aa77a65a22c
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Set.Base.Set Lib.OpenEdge
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,U(U)><L,U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Types.Int
                   ww3 :: Data.Set.Base.Set Lib.OpenEdge ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Data.Set.Base.$w$cshowsPrec
                       @ (Lib.Coord, Lib.Dir)
                       Lib.$fShowMaze_$s$fShow(,)
                       0
                       ww3
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowMaze7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Lib.$fShowMaze6
                          (case ww1 of ww4 { GHC.Types.I# ww5 ->
                           case GHC.Show.$wshowSignedInt
                                  0
                                  ww5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Lib.$fShowMaze5
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        Lib.$fShowMaze4
                                        (case ww2 of ww6 { GHC.Types.I# ww7 ->
                                         case GHC.Show.$wshowSignedInt
                                                0
                                                ww7
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Lib.$fShowMaze5
                                                   (GHC.Base.++
                                                      @ GHC.Types.Char
                                                      Lib.$fShowMaze3
                                                      (f (GHC.Base.++
                                                            @ GHC.Types.Char
                                                            Lib.$fShowMaze2
                                                            x)))) of ww8 { (#,#) ww9 ww10 ->
                                         GHC.Types.:
                                           @ GHC.Types.Char
                                           ww9
                                           ww10 } }))) of ww6 { (#,#) ww7 ww8 ->
                           GHC.Types.: @ GHC.Types.Char ww7 ww8 } }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
195668d4b335291f078830c9beaea7d3
  type Coord = (GHC.Types.Int, GHC.Types.Int)
af4f6b0a3910f299578d32f952a46abe
  data Dir = Right | Down
    Promotable
6f3f06d130aa862b1403d0e24d09db22
  data Maze
    = Maze {mazeWidth :: GHC.Types.Int,
            mazeHeight :: GHC.Types.Int,
            openMazeGates :: Data.Set.Base.Set Lib.OpenEdge}
826a3773628477790121286a661410a2
  type OpenEdge = (Lib.Coord, Lib.Dir)
c583bed3ebcdc6b95e568cf7d2cf1954
  data Wall = Open | Closed
    Promotable
88d06c642f811ae71b5cda8b17c4d964
  mazeHeight :: Lib.Maze -> GHC.Types.Int
  RecSel Lib.Maze
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.Maze ->
                 case ds of wild { Lib.Maze ds1 ds2 ds3 -> ds2 }) -}
91733c79c40d1312a2948d4db4421ea4
  mazeWidth :: Lib.Maze -> GHC.Types.Int
  RecSel Lib.Maze
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.Maze ->
                 case ds of wild { Lib.Maze ds1 ds2 ds3 -> ds1 }) -}
3105c058ad2d4f375ffbd6339a37b8b1
  openMazeGates :: Lib.Maze -> Data.Set.Base.Set Lib.OpenEdge
  RecSel Lib.Maze
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lib.Maze ->
                 case ds of wild { Lib.Maze ds1 ds2 ds3 -> ds3 }) -}
7fb4a03c566dc51ef89f1daf0ce47219
  someFunc :: t
  {- Strictness: b,
     Unfolding: InlineRule (0, True, True) GHC.Err.undefined -}
instance GHC.Classes.Eq [Lib.Dir] = Lib.$fEqDir
instance GHC.Classes.Eq [Lib.Maze] = Lib.$fEqMaze
instance GHC.Classes.Eq [Lib.Wall] = Lib.$fEqWall
instance GHC.Classes.Ord [Lib.Dir] = Lib.$fOrdDir
instance GHC.Classes.Ord [Lib.Wall] = Lib.$fOrdWall
instance GHC.Show.Show [Lib.Dir] = Lib.$fShowDir
instance GHC.Show.Show [Lib.Maze] = Lib.$fShowMaze
instance GHC.Show.Show [Lib.Wall] = Lib.$fShowWall
"SPEC/Lib $fEq(,) @ (Int, Int) @ Dir" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                                (GHC.Types.Int, GHC.Types.Int)
                                                      $dEq1 :: GHC.Classes.Eq Lib.Dir
  GHC.Classes.$fEq(,) @ (GHC.Types.Int, GHC.Types.Int)
                      @ Lib.Dir
                      $dEq
                      $dEq1
  = Lib.$fEqMaze_$s$fEq(,)
"SPEC/Lib $fEq(,) @ Int @ Int" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                         GHC.Types.Int
                                               $dEq1 :: GHC.Classes.Eq GHC.Types.Int
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Lib.$fEqMaze_$s$fEq(,)1
"SPEC/Lib $fShow(,) @ (Int, Int) @ Dir" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                    (GHC.Types.Int, GHC.Types.Int)
                                                        $dShow1 :: GHC.Show.Show Lib.Dir
  GHC.Show.$fShow(,) @ (GHC.Types.Int, GHC.Types.Int)
                     @ Lib.Dir
                     $dShow
                     $dShow1
  = Lib.$fShowMaze_$s$fShow(,)
"SPEC/Lib $fShow(,) @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                             GHC.Types.Int
                                                 $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,) @ GHC.Types.Int @ GHC.Types.Int $dShow $dShow1
  = Lib.$fShowMaze_$s$fShow(,)1
"SPEC/Lib $fShow(,)_$cshow @ (Int, Int) @ Dir" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                           (GHC.Types.Int,
                                                                            GHC.Types.Int)
                                                               $dShow1 :: GHC.Show.Show Lib.Dir
  GHC.Show.$fShow(,)_$cshow @ (GHC.Types.Int, GHC.Types.Int)
                            @ Lib.Dir
                            $dShow
                            $dShow1
  = Lib.$fShowMaze_$s$fShow(,)_$cshow1
"SPEC/Lib $fShow(,)_$cshow @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                    GHC.Types.Int
                                                        $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshow @ GHC.Types.Int
                            @ GHC.Types.Int
                            $dShow
                            $dShow1
  = Lib.$fShowMaze_$s$fShow(,)_$cshow
"SPEC/Lib $fShow(,)_$cshowList @ (Int, Int) @ Dir" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                               (GHC.Types.Int,
                                                                                GHC.Types.Int)
                                                                   $dShow1 :: GHC.Show.Show Lib.Dir
  GHC.Show.$fShow(,)_$cshowList @ (GHC.Types.Int, GHC.Types.Int)
                                @ Lib.Dir
                                $dShow
                                $dShow1
  = Lib.$fShowMaze_$s$fShow(,)_$cshowList
"SPEC/Lib $fShow(,)_$cshowList @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                        GHC.Types.Int
                                                            $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshowList @ GHC.Types.Int
                                @ GHC.Types.Int
                                $dShow
                                $dShow1
  = Lib.$fShowMaze_$s$fShow(,)_$cshowList1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

