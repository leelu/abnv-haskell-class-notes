* 2016-02-22
1. Env setup
   - stack install
   - cabal was a lower level build tool, but stack is better
   - mac installation via brew: http://docs.haskellstack.org/en/stable/install_and_upgrade/#mac-os-x
   - `stack install ghc-mod hlint hoogle cabal-install hasktags`
   - `stack setup`
   - add to PATH: ~/local/.bin
2. On editors and IDEs
   - haskell isn't mainstream, so there aren't IDEs out there
   - Atom is quite feature filled, Emacs is great too.
   - http://haskellformac.com/
3. Reading material and community
   - http://reddit.com/r/haskell
   - books: Learn you a Haskell - beginner friendly, Real world haskell - not beginner friendly.
   - new, and good for learning haskell from scratch: http://haskellbook.com/
   - Guide: https://github.com/bitemyapp/learnhaskell, cis194 (we're following this)
4. On Haskell
   - started in 1991, roots in academics - designed in detail and then implemented
   - Can be intimidating - you don't need to be good at math to be good at haskell
   - Compiler keeps yelling at you to get things right. So you can be stupid.
   - What differentiates haskell:
     - Strongly, Statically typed, Type inference
       - Java is also strongly and statically typed, but does not have type inference
       #+begin_src haskell
           Prelude> 1+'1'

           <interactive>:2:2:
           No instance for (Num Char) arising from a use of ‘+’
           In the expression: 1 + '1'
           In an equation for ‘it’: it = 1 + '1'

           Prelude> :t 234
           234 :: Num a => a
       #+end_src
     - Functional
       - Functions are first class
       #+begin_src haskell
        Prelude> :t (+)
        (+) :: Num a => a -> a -> a
       #+end_src
     - Immutable (by default)
       - Bindings, objects, lists, etc, everything is immutable by default
     - Lazy
       - Call by name, not value - arguments are not evaluated first
       - Think of this as a tree, with paths/nodes that don't need to
         be evaluated. The compiler goes through the tree, and you
         imagine that it builds a single line of code containing all
         the necessary things that needs to run.
       - Scala and Clojure have lazy lists and such, but evaluation
         isn't lazy like in Haskell.
       #+begin_src haskell

           Prelude> let a = 1
           Prelude> let a =3
           Prelude> :set -Wall
           Prelude> let a = 4

           <interactive>:15:5: Warning:
           This binding for ‘a’ shadows the existing binding
           defined at <interactive>:13:5

           Prelude> let addOne x = x + 1
           Prelude> addOne (1)
           2
           Prelude> :t addOne
           addOne :: Num a => a -> a
           Prelude> addOne (1 + 1)
           3
           Prelude> addOne(error "FAIL")
	 #+end_src
     - Pure
       - enforced by the compiler
       - addOne 6 is always 7. Referrential transparency. Not always in other languages.
       #+begin_src haskell
         Prelude> :t getChar
         getChar :: IO Char
        #+end_src
   - GHC is a compiler for haskell.
   - runhaskell is an interpreter for haskell.
   - ghci - REPL - backed by the ghc. 1+"1" is not a runtime exception, it is a compile exception.
5. Lists and tuples
  #+begin_src haskell
        Prelude> [1,2,3]
        [1,2,3]
        Prelude> :t [1, 2, 3]
        [1, 2, 3] :: Num t => [t]
        Prelude> :t ["a", "b"]
        ["a", "b"] :: [[Char]]
        Prelude> :t 'c'
        'c' :: Char
        Prelude> :t "c"
        "c" :: [Char]
        Prelude> [1, "asd"]

        <interactive>:17:2:
            No instance for (Num [Char]) arising from the literal ‘1’
            In the expression: 1
            In the expression: [1, "asd"]
            In an equation for ‘it’: it = [1, "asd"]
        Prelude> ['a','s','d','f']
        "asdf"


        Prelude> let x = [1.. 7]
        Prelude>
        Prelude> x
        [1,2,3,4,5,6,7]
        Prelude> let x = [1.. ]
        Prelude>
        Prelude> x
        [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,....

        Prelude> (1, 2.0, "sadf")
        (1,2.0,"sadf")
        Prelude> :t (1, 2.0, "sadf")
        (1, 2.0, "sadf") :: (Fractional t1, Num t) => (t, t1, [Char])
        Prelude> :t (1, "sadf")
        (1, "sadf") :: Num t => (t, [Char])
  #+end_src
6. Hoogle
7. Homework
8. write a rot13 cipher
* 2016-02-23
** Recap
1. Understanding basic types and reading type definitions
    #+begin_src haskell
    Prelude> let square x = x * x
    Prelude> :t square
    square :: Num a => a -> a

    Prelude> let squareAndAdd x y = x * x + y
    Prelude> :t squareAndAdd
    squareAndAdd :: Num a => a -> a -> a

    Prelude> let name = "haskell"
    Prelude> :t name
    name :: [Char]

    Prelude> :t [1,2,3,4,5]
    [1,2,3,4,5] :: Num t => [t]


    #+end_src
  - last entity after -> is the return type
  - before the "fat arrow" (=>) tells you the type of arguments
  - there are no variables, there are only "bindings"
  - we'll still refer to them as variables for comfort/convenience
  - think of variables as functions without arguments
2. Loading modules in the REPL
   #+begin_src haskell
    Prelude> :m +Data.List
    Prelude Data.List> :m -Data.List
   #+end_src
  - hit [tab] after "Data.List." to list all functions
3. Some list operations
  #+begin_src haskell
    Prelude Data.List> [1..4] ++ [10..15]
    [1,2,3,4,10,11,12,13,14,15]

    Prelude Data.List> maximum [1..100]
    100

    Prelude Data.List> take 5 (repeat 1)
    [1,1,1,1,1]

    Prelude Data.List> [1..10] !! 3
    4

    Prelude Data.List> concat [[1..4], [3..5], [1..4]]
    [1,2,3,4,3,4,5,1,2,3,4]

    Prelude Data.List> take 10 (cycle [1,2,3])
    [1,2,3,1,2,3,1,2,3,1]
  #+end_src
  - take, drop, concat, head, tail, !!
4. On Nulls
  - are one of the biggest mistakes in programming
  - head is unsafe
  #+begin_src haskell
  Prelude Data.List> head []
  Exception: Prelude.head: empty list
  #+end_src
5. Rot13

** adhoc
- remember: lists are linked lists
- undefined lets the code compiles, but fails in runtime
    - used when writing large chunks of code and incrementally filling in gaps
- hs is the extension for haskell files

** Today's learnings
1. Functions more than one line
  #+begin_src haskell
  -- multi clause function
  sumTill 1 = 1
  sumTill n = n + sumTill (n - 1)

  -- guard patterns
  sumTill' n
   | n == 1 = 1
   | otherwise = n + sumTill' (n - 1)


  -- case
  sumTill'' n = case n of
    1 -> 1
    _ -> n + sumTill'' (n - 1)

  -- you can mix them
  func x 1
   | x == 1 = 0
  func x y = 999
  #+end_src
  - guard-pattern translates to if - checks happen at run time
  - multi-clause translates to case - checks happen in compile time
  - non exhaustive pattern search

  - there's a limit to recursion that's the stack size set using a flag
  - ghc does tail call elimination

2. where and let
  #+begin_src haskell
  -- top-bottom style
  addOneSquare x = y * y
    where y = x+1

  -- bottom-top style
  addOneSquare' x =  let y = x + 1
                      in y * y
  #+end_src

3. Aside
  - what is otherwise?
  #+begin_src haskell
  *Main> otherwise
  True
  #+end_src

4. List comprehensions
  #+begin_src haskell
  *Main> [ x*x | x <- [1..10]]
  [1,4,9,16,25,36,49,64,81,100]

  *Main> [ (x,y) | x <- [1,2], y <- ['a','b']]
  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]

  -- conditions
  *Main> [ (x,y) | x <- [1,2], y <- [1..10], x == y ]
  [(1,1),(2,2)]

  -- let bindings
  *Main> [ (x,y,z) | x <- [1,2], y <- [1..10], x == y, let z = x + 1 ]
  [(1,1,2),(2,2,3)]
  #+end_src

5. Today's homework
  - https://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
